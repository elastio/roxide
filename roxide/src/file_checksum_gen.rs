// Rust wrapper for FileChecksumGenCrc32c class. It's useful for validating SST files checksums,
// generated by rocksDB itself.

use std::ffi;

pub struct FileChecksumGenCrc32c {
    raw_generator_ptr: *mut ffi::c_void,
}

cpp! {{
    #include "src/lib.h"
}}

impl FileChecksumGenCrc32c {
    pub fn new() -> Self {
        let raw_generator_ptr = unsafe {
            cpp!([] -> *mut libc::c_void as "rocksdb::FileChecksumGenerator*" {
                auto factory = rocksdb::GetFileChecksumGenCrc32cFactory();
                // Empty context, since FileChecksumGenCrc32c doesn't use it anyway
                FileChecksumGenContext ctx{};
                auto generator = factory->CreateFileChecksumGenerator(ctx);
                // Here we release raw pointer from unique_ptr, and it's our responsibility to delete
                // it manually later.
                auto* generator_raw_generator_ptr = generator.release();
                return generator_raw_generator_ptr;
            })
        };

        Self { raw_generator_ptr }
    }

    #[allow(clippy::transmute_num_to_bytes)]
    pub fn update(&mut self, data: &[u8]) {
        let raw_generator_ptr = self.raw_generator_ptr;
        let len = data.len();
        let data_ptr = data.as_ptr();
        unsafe {
            cpp!([raw_generator_ptr as "rocksdb::FileChecksumGenerator*", data_ptr as "const char*", len  as "size_t"] {
                raw_generator_ptr->Update(data_ptr, len);
            });
        }
    }

    pub fn finalize(&mut self) {
        let raw_generator_ptr = self.raw_generator_ptr;
        unsafe {
            cpp!([raw_generator_ptr as "rocksdb::FileChecksumGenerator*"] {
                raw_generator_ptr->Finalize();
            });
        }
    }

    pub fn get_checksum(&self) -> u32 {
        let raw_generator_ptr = self.raw_generator_ptr;
        unsafe {
            cpp!([raw_generator_ptr as "rocksdb::FileChecksumGenerator*"] -> u32 as "uint32_t" {
                auto checksum = raw_generator_ptr->GetChecksum();
                // Default CRC32c checksum generator stores checksum inside std::string
                // using reinterpret_cast, so we can't convert it to rust string using
                // to_string_lossy(), because it will replace invalid UTF-8 characters
                uint32_t checksum_uint = checksum.length() == 4
                                ? *reinterpret_cast<const uint32_t*>(checksum.data())
                                : 0u;
                return checksum_uint;
            })
        }
    }
}

// Delete native C++ object
impl Drop for FileChecksumGenCrc32c {
    fn drop(&mut self) {
        let raw_generator_ptr = self.raw_generator_ptr;
        unsafe {
            cpp!([raw_generator_ptr as "rocksdb::FileChecksumGenerator*"] {
                delete raw_generator_ptr;
            });
        }

        self.raw_generator_ptr = std::ptr::null_mut();
    }
}

impl Default for FileChecksumGenCrc32c {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod test {
    use crate::db::db::*;
    use crate::db::DbLike;
    use crate::ops::Compact;
    use crate::test::TempDbPath;
    use crate::Result;
    use crate::{DbOpen, FileChecksumGenCrc32c, GetLiveFiles};

    fn create_test_db() -> Result<(TempDbPath, Db, DbColumnFamily)> {
        let path = TempDbPath::new();
        let db = Db::open(&path, None)?;
        let cf = db.get_cf("default").unwrap();

        Ok((path, db, cf))
    }

    #[test]
    /// Calculate checksum for SST file and compare it with checksum in live file metadata
    fn calculate_sst_file_crc32c() -> Result<()> {
        let (_path, db, cf) = create_test_db()?;
        crate::test::fill_db(&db, &cf, 10_000)?;
        db.compact_all(&cf, None)?;
        let live_files = db.get_live_files()?;
        assert_eq!(1, live_files.len());
        let sst = live_files.first().unwrap();

        let file_data = std::fs::read(sst.file_path.clone()).unwrap();

        let mut checksum_gen = FileChecksumGenCrc32c::new();
        checksum_gen.update(file_data.as_slice());
        checksum_gen.finalize();

        assert_eq!(sst.crc32c_checksum, checksum_gen.get_checksum());

        Ok(())
    }
}
